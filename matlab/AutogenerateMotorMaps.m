%% Autogenerated Motormaps
%% only for testbed computer

close all
clear all
stage = 'stage1';

%% Define test directory with folders containing the streak images
topdir = 'D:\PfsTests\2_26_15_09__MyCenters\';

numBuckets = 100;
% bwfactor = 2; % reduce this if your circles dont appear fully on the bw image.
bwfactor = 5; %
notok = true;
% cirSensitivity = 0.85; % 0.85 seems to work for theta
cirSensitivity = 0.92; %92; % CircleFinder Sensitivity 0.9 default.
images = dir2cell([topdir '*.fits']);

while notok
  %Define the Range in which the Circle-Radii are.
  radiusRange = [20, 120];
  
  % Define the width of the radius-gap to measure the intensity.
  
  
  intensities.pId1 = [];
  intensities.pId2 = [];
  intensities.pId3 = [];
  intensities.pId4 = [];
  intensities.pId5 = [];
  intensities.pId6 = [];
  intensities.pId7 = [];
  intensities.pId8 = [];
  intensities.pId9 = [];
  
  overloads = [];
  imageMatrix = [];
  
  %%  Set Flowrates
  flowrate.pId1 = 4778;
  flowrate.pId2 = 4557;
  flowrate.pId3 = 4511;
  flowrate.pId4 = 5019;
  flowrate.pId5 = 3005;
  flowrate.pId6 = 1426;
  flowrate.pId7 = 4753;
  flowrate.pId8 = 1000;			
  flowrate.pId9 = 1000;
  
  %% Load a image reverse streaks stageX
%   for nim = [2:length(images)]
%     imagefile = images{nim};
%     if(strfind(imagefile, 'streaks1rv_'))
%       fitsfile =imagefile;
%     elseif  (strfind(imagefile, 'streaks2rv_'))
%       fitsfile =imagefile;
%     elseif  (strfind(imagefile, 'streakCenterms1'))
%       fitsfile =imagefile;
%     end
%   end
    fitsfile = images{4};
  img = imread(fitsfile);
  imgsize = size(img);
 
  
  % Reshape img to a row vector
  % imrs = reshape(img, 1, []);
  % % Calculate noise ceiling
  % myLowerThresh = bwfactor* mean(imrs);
  % % ?
  % imrs = [];
  % % Create bw image using noise ceiling to cut out everything below it
  % bw_mine  = (img > myLowerThresh);
  % Show image with everything below noise ceiling zerod out
  % img_wo_noise = img;
  % img_wo_noise(img_wo_noise < myLowerThresh) = 0;
  % figure('name','img wo noise')
  % hold off
  % imshow(img_wo_noise)
  
  sigma = mean(abs(reshape(img,1,[])));
  bw_mine = (img<bwfactor*sigma);
  
  figure(1), imagesc(bw_mine);
  hold on;
  
  %% Find centers and radii
  
  [centers, radii] = imfindcircles(bw_mine, radiusRange,'ObjectPolarity','bright', 'Sensitivity' , cirSensitivity);
  [r, c, rad] = circlefinder(bw_mine, radiusRange(1), radiusRange(2), 0.13);
  if(~isempty(centers))
    
    crm = horzcat(centers, radii);
    crm = sortrows(crm, 1);
    crm = flipud(crm);
    crm = horzcat(crm(:,1) + 1i * crm(:,2), crm(:,3));
    %cs = centers(:,1) + centers(:,2) * 1i;
  else
    cs = c + r * 1i;
    radii = rad;
    crm = horzcat(cs, radii);
    crm = sortrows(crm);
    crm = flipud(crm);
  end
  
  if ~isempty(crm)
    plot(crm(:,1), 'r*');
  end
  
  %% Create Window to /Check
  % Construct a questdlg with three options
  choice = questdlg('Are all positioner centers found?', ...
                    'Center Check in Figure 1', ...
                    'Yes','No, the circles are to faint', 'No, the circles are to thick', 'No, the circles are to thick');
  % Handle response
  switch choice
    case 'Yes'
      disp([choice ' coming right up.'])
      notok = false
    case 'No, the circles are to faint'
      disp([choice 'I will decrease threshold and rerun.'])
      bwfactor = bwfactor*.75;
    case 'No, the circles are to thick'
      disp('I''ll increase threshold and rerun.')
      bwfactor = bwfactor*1.25;
  end
end

keyboard;
%% Calculate Intensity

% Angular size of the pie:
resolution_angle=2*pi/numBuckets;
angles=[resolution_angle:resolution_angle:2*pi];
check = 0;
cc=1;

% centerDirs = centerDirs(1:end-2)
for nDir = [1:length(images)-0]
  
  disp(strcat('Now processing',images(nDir)));
  
  %% Define function inputs and current setup
  % What directory are all the center metrology images kept in
  % Must use and end with /
  %imagefile = char(strcat(topdir,images(nDir)));
  imagefile = char(images(nDir));
  %Read Intensity
  imageMatrix=imread(imagefile);
  %imageMatrix=uint32(imageMatrix);
  disp(imagefile);
  
  
  %to die, to sleep;To sleep: perchance to dream: ay, there's the rub;
  %For in that sleep of death what dreams may come
  for ps = 1:length(crm(:,1))
    use = true;
    pid = sprintf('pId%d',ps) ;
    cobracenter = crm(ps,1);
    min_range = floor(crm(ps,2)) - 5;
    max_range = floor(crm(ps,2)) + 15;
    [intensity.(pid), overload ] = getIntensityN( cobracenter, min_range, max_range, imageMatrix, resolution_angle, topdir, nDir, numBuckets, 0,ps);
    if(check < length(crm(:,1)))
      choice = questdlg('Is the streak fully visible?', ...
                        'Radius Check in Figure 15', ...
                        'Yes','No, this image has no data','No, radii are not ok', 'No, radii are not ok');
      % Handle response
      switch choice
        case 'Yes'
          check = check +1;
          use = true;
        case 'No, this image has no data'
          use = false;
          break;
        case 'No, radii are not ok'
          disp([choice 'Change the radius settings and rerun.'])
          return;
      end 
    end
    if( use)
      intensities.(pid) = vertcat(intensities.(pid), intensity.(pid));
      overloads = vertcat(overloads, overload);
    end
  end
  
end



%% Find Maximum intensity -> HS

for ps = [1:length(crm(:,1))]
  pid = sprintf('pId%d',ps) ;
  cobracenter = crm(ps,1);
  min_range = floor(crm(ps,2)) - 5;
  max_range = floor(crm(ps,2)) + 10;
  [intensityReverse.(pid), overload ] = getIntensityN( cobracenter, min_range, max_range, img, resolution_angle, topdir, nDir, numBuckets, 1, 1 );
  mv = max(intensityReverse.(pid));
  hsind.(pid) = find(intensityReverse.(pid) ==mv);
end


%% Calculate Averaged Speed Maps

for ps = 1:length(crm(:,1))
  pid = sprintf('pId%d',ps) ;
  %     %Usually the mean
  meansityFw.(pid) = mean(double((intensities.(pid)(1:2:end-1, :))));
  meansityRv.(pid) = mean(double((intensities.(pid)(2:2:end, : ))));
  %     
  %     meansityFw.(pid) = mean(double((intensities.(pid)(1:end/2, :))));
  %     meansityRv.(pid) = mean(double((intensities.(pid)(end/2:end, : ))));
  %     But we just have one image:
  % meansityFw.(pid) = intensities.(pid)(1,:);
  % meansityRv.(pid) = intensities.(pid)(2,:);
  meansAvFw.(pid) = [(meansityFw.(pid)(1)+meansityFw.(pid)(2))/2 (meansityFw.(pid)(1:end-2)+meansityFw.(pid)(2:end-1)+meansityFw.(pid)(3:end))/3 (meansityFw.(pid)(end-1)+meansityFw.(pid)(end))/2];
  meansAvRv.(pid) = [(meansityRv.(pid)(1)+meansityRv.(pid)(2))/2 (meansityRv.(pid)(1:end-2)+meansityRv.(pid)(2:end-1)+meansityRv.(pid)(3:end))/3 (meansityRv.(pid)(end-1)+meansityRv.(pid)(end))/2];
  
  dPSavFw.(pid) =  flowrate.(pid)*(360/numBuckets) ./double(meansAvFw.(pid));
  dPSavRv.(pid) =  flowrate.(pid)*(360/numBuckets) ./double(meansAvRv.(pid));
  %     % figure(20+ps)
  % clf
  % hold on
  % axis([0 100 0 0.2]);
  % plot(dPSavFw.(pid), 'r');
  % plot(dPSavRv.(pid), 'b');
  
end



%% Create Motor Map from HS
buckets = linspace(3.6, 360,numBuckets+1);
for ps = 1:length(crm(:,1))
  pid = sprintf('pId%d',ps) ;
  
  %Put the neg Hardstop to the first bin.
  %Hsind = hardstop index of the specific map.
  dPSavFwHs.(pid) = [dPSavFw.(pid)(hsind.(pid):end), dPSavFw.(pid)(1:hsind.(pid))];
  dPSavRvHs.(pid) = [dPSavRv.(pid)(hsind.(pid):end), dPSavRv.(pid)(1:hsind.(pid))];
  %Smoth the beginning: first 36 degrees are a line from value of 9 to 10.
  dPSavFwHs.(pid)(1:10) = linspace(dPSavFwHs.(pid)(9), dPSavFwHs.(pid)(10), 10);
  dPSavRvHs.(pid)(1:10) = linspace(dPSavRvHs.(pid)(9), dPSavRvHs.(pid)(10), 10);
  % Smooth the end.
  dPSavFwHs.(pid)(end-3:end) = dPSavFwHs.(pid)(end-4);
  dPSavRvHs.(pid)(end-3:end) = dPSavRvHs.(pid)(end-4);
  % Smooth the end for s2.
  if stage == 'stage2'
    dPSavFwHs.(pid)(38:45) = dPSavFwHs.(pid)(37);
    dPSavRvHs.(pid)(38:45) = dPSavRvHs.(pid)(37);
    % Cut the motor maps at the end
    dPSavFwHs.(pid)(46:end) = [];
    dPSavRvHs.(pid)(46:end) = [];
    buckets(46:end) = [];
    %Make the last angle a bit larger to protect from Msim failure
    buckets(45) = 190;
    
    motorMapFw.(pid) = [buckets; dPSavFwHs.(pid)];% times damping.*1.09;
    motorMapRv.(pid) = [buckets; dPSavRvHs.(pid)];% times damping.*1.09;
  else
    %Make the last angle a bit larger to protect from Msim failure
    buckets(100) = 402;
    motorMapFw.(pid) = [buckets; dPSavFwHs.(pid)];% times damping.*1.09;
    motorMapRv.(pid) = [buckets; dPSavRvHs.(pid)];% times damping.*1.09;
    motorMapFw.(pid)(:,end) = []; 
    motorMapRv.(pid)(:,end) = []; 
  end    
end 

%Generate all MotorMap images
for ps = 1:length(crm(:,1))
  pid = sprintf('pId%d',ps) ;
  figure(40+ps)
  clf
  hold on
  axis([0 100 0 0.2]);
  % plot(dPSavFw.(pid), 'r');
  % plot(dPSavRv.(pid), 'b');
  plot(motorMapFw.(pid)(2,:), 'm');
  plot(motorMapRv.(pid)(2,:), 'c');
end
imageMatrix = [];
bw_mine= [];
img = [];
save(horzcat(topdir,'workspace',stage,'.mat'));
% save(horzcat('C:\Users\sage\Desktop\Dropbox\PFS_EM\TEST_RESULTS\StreakResults\DailyBenchmarkResults/','workspace_',stage,date,'.mat'));
