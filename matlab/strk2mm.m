%% Autogenerated Motormaps 
close all
clear all
stage = 'stage1';

%% Define test directory with folders containing the streak images
topdir = './';

%  topdir = 'D:\PfsTests\04_11_14_11_18_21\Images/';
% topdir = 'D:\PfsTests\03_30_14_09_26_45_streaks100\Images\s1/';
numBuckets = 360;
% bwfactor = 2; % reduce this if your circles dont appear fully on the bw image.
bwfactor = 20; % 
notok = true;
images = dir2cell([topdir '*.fits']);
while notok
  %Define the Range in which the Circle-Radii are.
  % radiusRange = [ 60, 120];
  % radiusRange = [ 110, 190];
  radiusRange = [40, 120];

  % Define the width of the radius-gap to measure the intensity. 
  
  intensities.pId1 = [];
  intensities.pId2 = [];
  intensities.pId3 = [];
  intensities.pId4 = [];
  intensities.pId5 = [];
  overloads = [];
  imageMatrix = [];

  %%  Set Flowrates
  % flowrate.pId1 = 6824;
  % flowrate.pId2 = 5083;
  % flowrate.pId3 = 8141;
  % flowrate.pId4 = 6425;
  % flowrate.pId5 = 7572;
  % flowrate.pId1 = 8240; 
  % flowrate.pId2 = 3937;
  % flowrate.pId3 = 6738;
  % flowrate.pId4 = 8167;
  % flowrate.pId5 = 7351;
  flowrate.pId1 = 9434; % As of 4/30/14
  flowrate.pId2 = 2862;
  flowrate.pId3 = 5971;
  flowrate.pId4 = 6406;
  flowrate.pId5 = 6088;


  %% Load a image reverse streaks stageX
  for nim = [1:length(images)]
    imagefile = char(strcat(topdir,images(nim)));
    if(strfind(imagefile, 'streaks1rv_')) 
      fitsfile =imagefile;
      % centerImage = strcat(topdir, 'streaks2rv_ImageId_1582_Target_99_Iteration_41_loopId_7_64.fits')
    elseif  (strfind(imagefile, 'streaks2rv_'))
      fitsfile =imagefile;
    elseif  (strfind(imagefile, 'centerStrk_'))
      fitsfile =imagefile;
    end     
  end
  % fitsfile = char(centerImage);
  img = fitsread(fitsfile);
  imgsize = size(img);
  
  imrs = reshape(img, 1, 2048*2048);
  myLowerThresh = bwfactor* mean(imrs);
  imrs = [];
  bw_mine  = (img > myLowerThresh);
  figure, imagesc(bw_mine);
  hold on;

  %% Find centers and radii

  [centers, radii] = imfindcircles(bw_mine, radiusRange,'ObjectPolarity','bright', 'Sensitivity' , 0.9);
  [r, c, rad] = circlefinder(bw_mine, radiusRange(1), radiusRange(2), 0.13);
  if(~isempty(centers))
    cs = centers(:,1) + centers(:,2) * 1i;
  else
    cs = c + r * 1i;
    radii = rad;
  end
  crm = horzcat(cs, radii);
  crm = sortrows(crm);
  crm = flipud(crm);

  plot(crm(:,1), 'r*');

  plot(crm(1,1), 'c*');
  plot(crm(2,1), 'r*');
  plot(crm(3,1), 'w*');
  plot(crm(4,1), 'm*');
  plot(crm(5,1), 'g*');


  %% Create Window to /Check
  % Construct a questdlg with three options
  choice = questdlg('Are all positioner centers found?', ...
                    'Center Check in Figure 1', ...
                    'Yes','No, the circles are to faint', 'No, the circles are to thick', 'No, the circles are to thick');
  % Handle response
  switch choice
    case 'Yes'
      disp([choice ' coming right up.'])
      notok = false
    case 'No, the circles are to faint'
      disp([choice 'I will decrease threshold and rerun.'])
      bwfactor = bwfactor/2;
    case 'No, the circles are to thick'
      disp('I''ll increase threshold and rerun.')
      bwfactor = bwfactor*2;
  end
end



%% Calculate Intensity

% Angular size of the pie: 
resolution_angle=2*pi/numBuckets;
angles=[resolution_angle:resolution_angle:2*pi];
check = 0;
% centerDirs = centerDirs(1:end-2)
for nDir = [1:length(images)-0]

  disp(strcat('Now processing',images(nDir)));

  %% Define function inputs and current setup
  % What directory are all the center metrology images kept in
  % Must use and end with /
  imagefile = char(strcat(topdir,images(nDir)));
  
  %Read Intensity
  imageMatrix=fitsread(imagefile);
  %  imageMatrix=uint32(imageMatrix);
  disp(imagefile);


  %to die, to sleep;To sleep: perchance to dream: ay, there's the rub;
  %For in that sleep of death what dreams may come
  for ps = 1:length(crm(:,1))
    use = true;
    pid = sprintf('pId%d',ps) ;
    cobracenter = crm(ps,1);
    min_range = floor(crm(ps,2)) - 10;
    max_range = floor(crm(ps,2)) + 5; 
    [intensity.(pid), overload ] = getIntensityN( cobracenter, min_range, max_range, imageMatrix, resolution_angle, topdir, nDir, numBuckets );
    if(check <  length(crm(:,1)))
      choice = questdlg('Is the streak fully visible?', ...
                        'Radius Check in Figure 15', ...
                        'Yes','No, this image has no data','No, radii are not ok', 'No, radii are not ok');
      % Handle response
      switch choice
        case 'Yes'
          check = check +1;
          use = true;
        case 'No, this image has no data'
          use = false;
          break;
        case 'No, radii are not ok'
          disp([choice 'Change the radius settings and rerun.'])
          return;
      end

    end 
    if( use)
      intensities.(pid) = vertcat(intensities.(pid), intensity.(pid));
      overloads = vertcat(overloads, overload);
    end
  end

end



%% Find Maximum intensity -> HS

for ps = [1:length(crm(:,1))]
  pid = sprintf('pId%d',ps) ;
  cobracenter = crm(ps,1);
  min_range = floor(crm(ps,2)) - 10;
  max_range = floor(crm(ps,2)) + 5;
  [intensityReverse.(pid), overload ] = getIntensityN( cobracenter, min_range, max_range, img, resolution_angle, topdir, nDir, numBuckets ); 
  mv = max(intensityReverse.(pid));
  hsind.(pid) = find(intensityReverse.(pid) ==mv);
end


%% Calculate Averaged Speed Maps

for ps = 1:length(crm(:,1))
  pid = sprintf('pId%d',ps) ; 
  meansityFw.(pid) = mean(double((intensities.(pid)(1:2:end-1, :))));
  meansityRv.(pid) = mean(double((intensities.(pid)(2:2:end, : ))));

  meansAvFw.(pid) = [(meansityFw.(pid)(1)+meansityFw.(pid)(2))/2 (meansityFw.(pid)(1:end-2)+meansityFw.(pid)(2:end-1)+meansityFw.(pid)(3:end))/3 (meansityFw.(pid)(end-1)+meansityFw.(pid)(end))/2];
  meansAvRv.(pid) = [(meansityRv.(pid)(1)+meansityRv.(pid)(2))/2 (meansityRv.(pid)(1:end-2)+meansityRv.(pid)(2:end-1)+meansityRv.(pid)(3:end))/3 (meansityRv.(pid)(end-1)+meansityRv.(pid)(end))/2];

  dPSavFw.(pid) =  flowrate.(pid)*(360/numBuckets) ./double(meansAvFw.(pid));
  dPSavRv.(pid) =  flowrate.(pid)*(360/numBuckets) ./double(meansAvRv.(pid));
  % figure(20+ps)
  % clf
  % hold on
  % axis([0 100 0 0.2]);
  % plot(dPSavFw.(pid), 'r');
  % plot(dPSavRv.(pid), 'b');
  
end



%% Create Motor Map from HS
buckets = linspace(3.6, 360,numBuckets+1);
for ps = 1:length(crm(:,1))
  pid = sprintf('pId%d',ps) ; 
  
  %Put the neg Hardstop to the first bin. 
  %Hsind = hardstop index of the specific map.
  dPSavFwHs.(pid) = [dPSavFw.(pid)(hsind.(pid):end), dPSavFw.(pid)(1:hsind.(pid))]; 
  dPSavRvHs.(pid) = [dPSavRv.(pid)(hsind.(pid):end), dPSavRv.(pid)(1:hsind.(pid))]; 
  %Smoth the beginning: first 36 degrees are a line from value of 9 to 10.
  dPSavFwHs.(pid)(1:10) = linspace(dPSavFwHs.(pid)(9), dPSavFwHs.(pid)(10), 10);
  dPSavRvHs.(pid)(1:10) = linspace(dPSavRvHs.(pid)(9), dPSavRvHs.(pid)(10), 10);
  % Smooth the end.   
  dPSavFwHs.(pid)(end-3:end) = dPSavFwHs.(pid)(end-4);
  dPSavRvHs.(pid)(end-3:end) = dPSavRvHs.(pid)(end-4);
  % Smooth the end for s2.
  if stage == 'stage2'
    dPSavFwHs.(pid)(38:45) = dPSavFwHs.(pid)(37);
    dPSavRvHs.(pid)(38:45) = dPSavRvHs.(pid)(37);
  end

  motorMapFw.(pid) = [buckets; dPSavFwHs.(pid)];% times damping.*1.09;
  motorMapRv.(pid) = [buckets; dPSavRvHs.(pid)];% times damping.*1.09;

  figure(30+ps)
  clf
  hold on
  axis([0 100 0 0.2]);
  % plot(dPSavFw.(pid), 'r');
  % plot(dPSavRv.(pid), 'b');
  plot(motorMapFw.(pid)(2,:), 'm');
  plot(motorMapRv.(pid)(2,:), 'c');
end

save(horzcat(topdir,'workspace',stage,'.mat'));

% Smothen Motor Map

